<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Selection</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        /* Add these styles in the head section */
        .course-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .course-card:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        /* Service Course Card Styles */
        .course-card.service-course {
            background: #f8fafc;
            border-left: 4px solid #3b82f6;
            border-top: 1px solid #e2e8f0;
            border-right: 1px solid #e2e8f0;
            border-bottom: 1px solid #e2e8f0;
        }

        .course-card.service-course label span {
            color: #1e40af;
            font-weight: 500;
        }

        .course-card.service-course select {
            border-color: #e2e8f0;
        }

        .course-card.service-course select:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .course-card.service-course .remove-course-btn {
            background-color: #3b82f6;
            color: white;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .course-card.service-course .remove-course-btn:hover {
            background-color: #2563eb;
        }

        .course-card.service-course::after {
            content: "Service Course";
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.75rem;
            color: #3b82f6;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .hidden-column {
            display: none;
        }

        /* Service Course Row Styling */
        .service-course-row {
            background-color: #f0f7ff !important;
            border-left: 4px solid #3b82f6 !important;
        }

        .service-course-row td {
            color: #1e40af;
        }

        .service-course-row:hover {
            background-color: #e6f0ff !important;
        }
    </style>
</head>
<body>
<!-- Reload Confirmation Modal -->
<div id="reloadModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; z-index: 1000;">
  <div style="background-color: #fff; margin: 15% auto; padding: 20px; border-radius: 8px; width: 300px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);">
    <h3>Resume Previous Session?</h3>
    <p>Would you like to reload previously saved courses?</p>
    <button id="confirmReload" style="margin-right: 10px;">Reload</button>
    <button id="cancelReload">Cancel</button>
  </div>
</div>
<script>
   function reloadCoursesFromData(parsedData) {
    const dynamicCourses = document.getElementById("dynamic-courses");

    // Clear current UI
    dynamicCourses.innerHTML = '';
    addedCourses.clear();
    Object.keys(courseSections).forEach(key => delete courseSections[key]);
    Object.keys(instructorCredits).forEach(key => delete instructorCredits[key]);

    parsedData.courses.forEach(({ courseName, instructor, section, year, time }) => {
        const [courseCode, courseTitle] = courseName.split(' - ');

        const courseCard = document.createElement("div");
        courseCard.className = "course-card";
        
        // Check if this is a service course
        const isServiceCourse = courseTitle.includes('(Service)');
        if (isServiceCourse) {
            courseCard.classList.add('service-course');
        }

        courseCard.innerHTML = `
            <button class="remove-course-btn" onclick="removeCourse('${section}')">&times;</button>
            <label style="display: flex; align-items: center;">
                <input type="checkbox" name="courses" value="${section}" checked>
                <span style="flex: 1;">${courseCode} - ${courseTitle}</span>
            </label>
            <select name="year_${section}">
                <option value="1" ${year == 1 ? "selected" : ""}>1st Year</option>
                <option value="2" ${year == 2 ? "selected" : ""}>2nd Year</option>
                <option value="3" ${year == 3 ? "selected" : ""}>3rd Year</option>
                <option value="4" ${year == 4 ? "selected" : ""}>4th Year</option>
                <option value="5" ${year == 5 ? "selected" : ""}>5th Year</option>
                <option value="6" ${year == 6 ? "selected" : ""}>Advanced</option>
            </select>
            <select name="instructor_${section}" class="instructor-dropdown">
                <option value="">Select Instructor</option>
            </select>
            <select name="time_${section}" class="time-dropdown">
                <option value="">Select Time (Optional)</option>
            </select>
            <input type="hidden" name="students_${section}" value="25">
        `;

        // Get the dropdowns
        const instructorSelect = courseCard.querySelector('.instructor-dropdown');
        const timeDropdown = courseCard.querySelector('.time-dropdown');

        if (isServiceCourse) {
            const tbaOption = document.createElement('option');
            tbaOption.value = 'TBA';
            tbaOption.textContent = 'TBA (Service)';
            instructorSelect.innerHTML = '';
            instructorSelect.appendChild(tbaOption);
            instructorSelect.value = 'TBA';
            instructorSelect.disabled = true;

            timeDropdown.innerHTML = '<option value="">Select Time (Required)</option>';
            timeSlots.forEach(slot => {
                const option = document.createElement('option');
                option.value = slot;
                option.textContent = slot;
                timeDropdown.appendChild(option);
            });

            if (time) timeDropdown.value = time;
        } else {
            // Populate instructor dropdown
            populateInstructorDropdown(instructorSelect);

            // Set the selected instructor if it exists
            if (instructor && instructorAvailability[instructor]) {
                instructorSelect.value = instructor;

                // Populate time slots for the selected instructor
                const instructorData = instructorAvailability[instructor];
                if (instructorData && instructorData.time_slots) {
                    timeDropdown.innerHTML = '<option value="">Select Time (Optional)</option>';
                    instructorData.time_slots.forEach(slot => {
                        const option = document.createElement('option');
                        option.value = slot;
                        option.textContent = slot;
                        timeDropdown.appendChild(option);
                    });

                    // Set the selected time if it exists
                    if (time) {
                        timeDropdown.value = time;
                    }
                }
            }
        }

        // Add instructor change handler
        instructorSelect.addEventListener('change', (e) => {
            const selectedInstr = e.target.value;
            const timeDropdown = courseCard.querySelector('.time-dropdown');

            // Clear time dropdown options
            timeDropdown.innerHTML = '<option value="">Select Time (Optional)</option>';

            // Handle instructor credit logic
            const courseInput = courseCard.querySelector('input[name^="courses"]');
            const courseWithSection = courseInput.value;
            const courseCode = courseWithSection.split('_')[0];
            const selectedCourse = courses.find(c => c.Code === courseCode);
            const courseCredits = selectedCourse ? selectedCourse.credits || 0 : 0;
            const newInstr = selectedInstr;
            const oldInstr = e.target.dataset.prevInstructor || '';

            // Handle old instructor's credits
            if (oldInstr && oldInstr !== newInstr && newInstr !== 'TBA') {
                instructorCredits[oldInstr] = (instructorCredits[oldInstr] || 0) - courseCredits;
                if (instructorCredits[oldInstr] <= 0) {
                    delete instructorCredits[oldInstr];
                }
            }

            // Determine max credits based on semester
            const isSummerSemester = semester === "Summer";
            const maxCredits = isSummerSemester ? 7 : 21;

            // Handle new instructor's credits (skip TBA)
            if (newInstr && newInstr !== 'TBA') {
                const currentCredits = instructorCredits[newInstr] || 0;
                if (currentCredits + courseCredits > maxCredits) {
                    showCustomAlert(`Error: ${newInstr} exceeds credit limit.`);
                    e.target.value = oldInstr;
                    return;
                }
                instructorCredits[newInstr] = currentCredits + courseCredits;
            }

            // Update stored previous value
            e.target.dataset.prevInstructor = newInstr;

            // Populate time slots based on instructor availability (skip TBA)
            if (!selectedInstr || selectedInstr === 'TBA') return;
            const instructorData = instructorAvailability[selectedInstr];
            if (!instructorData || !instructorData.time_slots) return;

            // Clear and populate time slots
            timeDropdown.innerHTML = '<option value="">Select Time (Optional)</option>';
            instructorData.time_slots.forEach(slot => {
                const option = document.createElement('option');
                option.value = slot;
                option.textContent = slot;
                timeDropdown.appendChild(option);
            });

            // Save after handling instructor logic
            saveCourses(true);
        });

        // Add save listener to all dropdowns
        courseCard.querySelectorAll('select').forEach(dropdown => {
            dropdown.addEventListener('change', () => {
                saveCourses(true);
            });
        });

        dynamicCourses.appendChild(courseCard);
        addedCourses.add(section);

        const [code, letter] = section.split('_');
        if (!courseSections[code]) courseSections[code] = [];
        courseSections[code].push(letter);
    });

    alert('Courses reloaded successfully!');
}
document.addEventListener('DOMContentLoaded', function () {
    const savedData = localStorage.getItem('savedCourses');
    if (!savedData) return;

    try {
        const parsedData = JSON.parse(savedData);
        const { school_code, campus_code, academic_year, semester } = parsedData;

        const currentSchoolCode = document.querySelector('input[name="school_code"]')?.value || '';
        const currentCampusCode = document.querySelector('input[name="campus_code"]')?.value || '';
        const currentAcademicYear = document.querySelector('input[name="academic_year"]')?.value || '';
        const currentSemester = document.querySelector('input[name="semester"]')?.value || '';

        // Only show modal if metadata matches
        if (
            school_code === currentSchoolCode &&
            campus_code === currentCampusCode &&
            academic_year === currentAcademicYear &&
            semester === currentSemester
        ) {
            const modal = document.getElementById('reloadModal');
            modal.style.display = 'block';

            document.getElementById('confirmReload').onclick = function () {
                reloadCoursesFromData(parsedData);
                modal.style.display = 'none';
            };

            document.getElementById('cancelReload').onclick = function () {
                modal.style.display = 'none';
            };
        }
    } catch (e) {
        console.error('Failed to parse saved data on load:', e);
    }
});
</script>
    <h1>Course Scheduler Pro</h1>
<!-- Save and Reload Buttons -->
<div style="margin-bottom: 20px;">
    <button type="button" id="save-courses" style="display: none;" >Save Courses</button>
    <input type="file" id="load-courses" style="display: none;" />
    <button type="button" id="reload-courses" style="display: none;" >Reload Courses</button>
    <a href="/add-service-courses?school_code={{ school_code }}&campus_code={{ campus_code }}&academic_year={{ academic_year }}&semester={{ semester }}" class="btn btn-primary">
    Add Service Courses
</a>
    <style>
        .btn {
    display: inline-block;
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    text-decoration: none;
    border-radius: 4px;
    margin-top: 20px;
}

.btn:hover {
    background-color: #0056b3;
}
    </style>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<!-- JavaScript for Save and Reload Functionality -->
<script>
 function saveCourses(silent = false) {
    console.log('ðŸš€ Starting course save operation...');

    const courses = [];
    const courseCards = document.querySelectorAll('.course-card');

    console.log(`Found ${courseCards.length} course cards to process`);

    courseCards.forEach((courseCard, index) => {
        try {
            // Get course data with fallback values
            const courseNameElement = courseCard.querySelector('label span');
            const courseName = courseNameElement?.innerText.trim() || 'Unknown Course';
            const instructorDropdown = courseCard.querySelector('.instructor-dropdown');
            const sectionInput = courseCard.querySelector('input[name^="courses"]');
            const yearSelect = courseCard.querySelector('[name^="year_"]');
            const timeSelect = courseCard.querySelector('.time-dropdown');

            // Extract values with fallbacks
            const instructor = instructorDropdown?.value || '';
            const section = sectionInput?.value || '';
            const year = yearSelect?.value || '';
            const time = timeSelect?.value || '';

            // Determine if this is a service course
            const isService = courseName.includes('(Service)');

            // Always push the course, even if instructor is unassigned
            courses.push({
                courseName,
                instructor,
                section,
                year,
                time,
                isService // ðŸ‘ˆ NEW FIELD ADDED HERE
            });

            // Log with appropriate emoji based on instructor status
            const emoji = instructor ? 'âœ…' : 'ðŸŸ¡';
            const instructorStatus = instructor ? `Instructor: ${instructor}` : 'No instructor assigned`';

            console.log(`${emoji} Processed course ${index + 1}: ${courseName} - ${instructorStatus}`);

        } catch (error) {
            console.error(`âŒ Error processing course card ${index + 1}:`, error);
        }
    });

    // Validate we have courses to save
    if (courseCards.length === 0) {
        console.warn('No course cards found in DOM');
        if (!silent) {
            alert('No courses found to save.');
        }
        return;
    }

    // Collect metadata
    const metadata = {
        school_code: document.querySelector('input[name="school_code"]')?.value || '',
        campus_code: document.querySelector('input[name="campus_code"]')?.value || '',
        academic_year: document.querySelector('input[name="academic_year"]')?.value || '',
        semester: document.querySelector('input[name="semester"]')?.value || ''
    };

    // Log collected data
    console.log('Metadata collected:', metadata);
    console.log('Courses to save:', courses);

    // Save to localStorage
    const savedData = {
        ...metadata,
        courses: courses
    };

    localStorage.setItem('savedCourses', JSON.stringify(savedData));
    console.log('ðŸ’¾ Successfully saved data to localStorage');

    // Show UI feedback only when not silent
    if (!silent) {
        const instructorlessCount = courses.filter(c => !c.instructor).length;
        const warning = instructorlessCount > 0 ?
            `\nâš ï¸ ${instructorlessCount} course(s) saved without instructor assignments` : '';

        alert(`Courses and settings saved successfully!${warning}`);
        console.log('âœ¨ UI feedback shown: Save successful');
    }
}
// Event listener for save button
document.getElementById('save-courses')?.addEventListener('click', () => {
    console.log('ðŸ–±ï¸ Save button clicked');
    saveCourses(false);
});

// Event listeners for dropdown changes
const dropdowns = document.querySelectorAll('.instructor-dropdown, .time-dropdown');
console.log(`Attaching change listeners to ${dropdowns.length} dropdowns`);

dropdowns.forEach(dropdown => {
    dropdown.addEventListener('change', () => {
        console.log(`ðŸ”„ Dropdown changed: ${dropdown.className}`);
        saveCourses(true);
    });
});

// Optional: Add mutation observer for dynamically added course cards
const observeCourseCards = () => {
    const targetNode = document.body;
    const config = { childList: true, subtree: true };

    const callback = (mutationsList) => {
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    if (node.classList?.contains('course-card')) {
                        console.log('ðŸ†• New course card detected');
                        saveCourses(true);
                    }
                });
            }
        }
    };

    const observer = new MutationObserver(callback);
    observer.observe(targetNode, config);
};

// Start observing for dynamic content
observeCourseCards();

console.log('âœ… Course saving system initialized');

function isServiceCourse(courseName) {
    const [courseCode] = courseName.split(' - ');
    const selectedCourse = courses.find(c => c.Code === courseCode);
    return selectedCourse && selectedCourse.Title.includes('(Service)');
}
</script>
    <!-- Custom Alert Box -->
    <div id="custom-alert">
        <div class="message"></div>
        <div class="progress-bar">
            <div class="progress-bar-inner"></div>
        </div>
    </div>

    <!-- Course Selection Form -->
    <div class="card">
        <form id="schedule-form" method="POST" action="/schedule">
            <!-- Hidden fields for school_code and campus_code -->
            <input type="hidden" name="school_code" value="{{ school_code }}">
            <input type="hidden" name="campus_code" value="{{ campus_code }}">
            <input type="hidden" name="academic_year" value="{{ academic_year }}">
            <input type="hidden" name="semester" value="{{ semester }}"> <!-- Added -->
            <!-- Course Selection Section -->
            <div class="card">
                <h3>Course Selection</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
    <select id="course-dropdown">
    <option value="">Select a Course</option>
    {% for course in courses %}
        <option value="{{ course.Code }}" data-course-year="{{ course.course_year }}">
            {{ course.Code }} - {{ course.Title }}
        </option>
    {% endfor %}
</select>
    <button type="button" id="add-course-btn" class="add-instructor-btn">Add Course</button>
</div>
                <div class="course-selection" id="dynamic-courses"></div>
                <button type="submit" style="margin-top: 20px;" class="add-instructor-btn">Generate Schedule</button>
            </div>
        </form>
    </div>
    <div class="card">
    <h3>Editable Schedule</h3>
   <!-- Add a dropdown for filtering instructors -->
<div class="card" style="margin-top: 20px;">
    <h3>Filter and Sort Options</h3>
    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
        <label for="instructor-filter">Filter by Instructor:</label>
        <select id="instructor-filter">
            <option value="">Show All</option>
        </select>
        <button id="sort-by-time-btn" class="add-instructor-btn">Sort by Time</button>
    </div>
</div>

<script>
// Function to populate the instructor filter dropdown with instructors who have courses assigned
function populateInstructorFilter() {
    const instructorFilterDropdown = document.getElementById("instructor-filter");
    const assignedInstructors = new Set();

    // Get all rows from the editable schedule table
    const rows = document.querySelectorAll("#editable-schedule tbody tr");

    // Extract unique instructors from the rows
    rows.forEach(row => {
        const instructorCell = row.querySelector("td:nth-child(4)").textContent.trim();
        if (instructorCell) {
            assignedInstructors.add(instructorCell);
        }
    });

    // Clear existing options
    instructorFilterDropdown.innerHTML = '<option value="">Show All</option>';

    // Add options for each assigned instructor
    assignedInstructors.forEach(instructor => {
        const option = document.createElement("option");
        option.value = instructor;
        option.textContent = instructor;
        instructorFilterDropdown.appendChild(option);
    });
}

function sortRowsByTime() {
    const rows = Array.from(document.querySelectorAll("#editable-schedule tbody tr"));

    // Helper function to extract the start time from a time slot string
    const extractStartTime = (timeSlot) => {
        if (!timeSlot) return Infinity; // Handle missing or invalid times
        const match = timeSlot.match(/(\d{1,2}:\d{2})/);
        if (!match) return Infinity; // Fallback for invalid formats
        const [hour, minute] = match[1].split(":").map(Number);
        return hour * 60 + minute; // Convert to minutes since midnight
    };

    // Sort rows based on the extracted start time
    rows.sort((rowA, rowB) => {
        const timeA = rowA.querySelector("td:nth-child(6)").textContent.trim(); // STIME column
        const timeB = rowB.querySelector("td:nth-child(6)").textContent.trim(); // STIME column

        // Extract start times and compare
        const startTimeA = extractStartTime(timeA);
        const startTimeB = extractStartTime(timeB);

        return startTimeA - startTimeB;
    });

    // Re-append sorted rows to the table body
    const tableBody = document.querySelector("#editable-schedule tbody");
    tableBody.innerHTML = ""; // Clear the table body
    rows.forEach(row => tableBody.appendChild(row)); // Append sorted rows
}
// Attach the event listener to the "Sort by Time" button
document.getElementById("sort-by-time-btn").addEventListener("click", () => {
    sortRowsByTime();
});

// Initialize functionality when the DOM is fully loaded
document.addEventListener("DOMContentLoaded", () => {
    // Populate the instructor filter dropdown initially
    populateInstructorFilter();

    // Observe changes in the table body to dynamically update the dropdown
    const observer = new MutationObserver(() => {
        populateInstructorFilter();
    });

    const tableBody = document.querySelector("#editable-schedule tbody");
    if (tableBody) {
        observer.observe(tableBody, { childList: true });
    }

    // Add event listener for instructor filtering
    document.getElementById("instructor-filter").addEventListener("change", (e) => {
        const selectedInstructor = e.target.value;
        const rows = document.querySelectorAll("#editable-schedule tbody tr");

        rows.forEach(row => {
            const instructorCell = row.querySelector("td:nth-child(4)").textContent.trim();
            if (selectedInstructor === "" || instructorCell === selectedInstructor) {
                row.style.display = ""; // Show the row
            } else {
                row.style.display = "none"; // Hide the row
            }
        });
        updateTableRowNumbers("editable-schedule");
    });

    // Add event listener for sorting by time
    document.getElementById("sort-by-time-btn").addEventListener("click", () => {
        sortRowsByTime();
    });
});
</script>
    <table id="editable-schedule" border="1">
   <thead>
    <tr>
        <th>#</th>
        <th>CODE</th>
        <th>Section</th>
        <th>FACUSER</th>
        <th>Room</th>
        <th>STIME</th>
        <th>ETIME</th>
        <th>M</th>
        <th>T</th>
        <th>W</th>
        <th>TH</th>
        <th>F</th>
        <th>S</th>
        <th>Campus</th>
        <th>University</th>
        <th class="hidden-column">AllowCross</th>
        <th class="hidden-column">schedulingType</th>
        <th class="hidden-column">bypassPayroll</th>
        <th class="hidden-column">Capacity</th>
    </tr>
</thead>
    <tbody>
        <!-- Rows will be dynamically added here -->
    </tbody>
</table>
    <button id="export-excel-btn" class="add-instructor-btn">Export to Excel</button>
</div>
    <script>
    const academicYear = "{{ academic_year }}";
    const semester = "{{ semester }}";
    console.log(`[DEBUG] Academic Year: ${academicYear}, Semester: ${semester}`);
</script>
    <script>
    var timeSlots = [
    {% if semester == "Summer" %}
        "MWTTH 8:00-9:50", "MWTTH 10:00-11:50", "MWTTH 12:00-1:50"
    {% else %}
        "MW 8:00-9:15 AM", "MW 9:30-10:45 AM", "MW 11:00 AM-12:15 PM",
    "MW 12:30-1:45 PM", "MW 2:00-3:15 PM", "MW 3:30-4:45 PM",
    "MW 5:00-6:15 PM", "MW 6:30-8:45 PM",
    "TTh 8:00-9:15 AM", "TTh 9:30-11:45 AM", "TTh 11:00 AM-12:15 PM",
    "TTh 12:30-1:45 PM", "TTh 2:00-3:15 PM", "TTh 3:30-4:45 PM",
    "TTh 5:00-6:15 PM", "TTh 6:30-8:45 PM"
    {% endif %}
];

    const courses = JSON.parse('{{ courses | tojson | safe }}');
    const instructors = JSON.parse('{{ instructors | tojson | safe }}');
    const addedCourses = new Set();
    const courseSections = {};
    let instructorAvailability = {}; // To store fetched instructor availability
    let instructorCredits = {}; // Track total credits assigned to each instructor

    document.addEventListener("DOMContentLoaded", function () {
    const schoolCode = "{{ school_code }}";
    const campusCode = "{{ campus_code }}";
    const academicYear = "{{ academic_year }}"; // Retrieve academic year from the template
    const semester = "{{ semester }}";         // Retrieve semester from the template
    console.log(`[DEBUG] Fetching instructor availability for school_code: ${schoolCode}, campus_code: ${campusCode}, academic_year: ${academicYear}, semester: ${semester}`);

    fetch(`/fetch_instructor_availability?school_code=${schoolCode}&campus_code=${campusCode}&academic_year=${academicYear}&semester=${semester}`)
        .then(response => response.json())
        .then(data => {
            console.log("[DEBUG] Received instructor availability data:", data);
            if (data.error) {
                console.error("[ERROR] Error fetching instructor availability:", data.error);
                showCustomAlert(`Error: ${data.error}`);
                return;
            }
            instructorAvailability = data.instructor_availability;
            console.log("[DEBUG] Extracted instructor availability:", instructorAvailability);

            // Populate all existing instructor dropdowns
            document.querySelectorAll('.instructor-dropdown').forEach(dropdown => {
                populateInstructorDropdown(dropdown);
            });
        })
        .catch(error => {
            console.error("[ERROR] Error fetching instructor availability:", error);
            showCustomAlert("Failed to load instructor availability.");
        });
});
</script>
    <script>
    // Function to populate instructor dropdowns dynamically
    const populateInstructorDropdown = (dropdown) => {
        dropdown.innerHTML = '<option value="">Select Instructor</option>';
        for (const [facuser, instructorData] of Object.entries(instructorAvailability)) {
            if (facuser === "TBA") continue;
            const option = document.createElement("option");
            option.value = facuser;
            const timeSlotCount = instructorData.time_slots ? instructorData.time_slots.length : 0;
            option.textContent = `${facuser} (${timeSlotCount} slots available)`;
            dropdown.appendChild(option);
        }
    };
</script>
<script>
    document.getElementById("add-course-btn").addEventListener("click", () => {
        const dropdown = document.getElementById("course-dropdown");
        const selectedCode = dropdown.value;
        if (!selectedCode) return;

        // Get the selected course details
        const selectedOption = dropdown.querySelector(`option[value="${selectedCode}"]`);
        const selectedCourse = courses.find(c => c.Code === selectedCode);

        // Default values for course year and credits
        const courseYear = selectedOption ? selectedOption.getAttribute("data-course-year") : "1";
        const courseCredits = selectedCourse ? selectedCourse.credits || 0 : 0;

        // Find the next available section letter (A, B, ..., Z, AA, AB, ..., AZ, BA, ...)
let nextLetter = '';
const existingSections = courseSections[selectedCode] || [];

// Helper function to generate section labels A-Z, AA-ZZ, AAA-ZZZ, etc.
function generateSectionLabel(index) {
    let label = '';
    while (index > 0) {
        index--;
        label = String.fromCharCode(65 + (index % 26)) + label;
        index = Math.floor(index / 26);
    }
    return label;
}

// Try up to 'ZZZ' (or increase this limit if needed)
for (let i = 0; i < 1000; i++) { // 1000 is a safe upper limit for many combinations
    const candidate = generateSectionLabel(i + 1); // start from 1 -> 'A'
    if (!existingSections.includes(candidate)) {
        nextLetter = candidate;
        break;
    }
}

        // Update course sections
        if (!courseSections[selectedCode]) courseSections[selectedCode] = [];
        courseSections[selectedCode].push(nextLetter);

        const courseWithSection = `${selectedCode}_${nextLetter}`;
        addedCourses.add(courseWithSection);

        // Create a new course card
        const courseCard = document.createElement("div");
        courseCard.className = "course-card";
        
        // Check if this is a service course
        const isServiceCourseCard = selectedCourse && selectedCourse.Title.includes('(Service)');
        if (isServiceCourseCard) {
            courseCard.classList.add('service-course');
        }

        courseCard.innerHTML = `
            <button class="remove-course-btn" onclick="removeCourse('${courseWithSection}')">&times;</button>
            <label style="display: flex; align-items: center;">
                <input type="checkbox" name="courses" value="${courseWithSection}" checked>
                <span style="flex: 1;">${selectedCode} ${nextLetter} - ${selectedCourse ? selectedCourse.Title : 'Custom Course'}</span>
            </label>
            <select name="year_${courseWithSection}">
                <option value="1" ${courseYear == 1 ? "selected" : ""}>1st Year</option>
                <option value="2" ${courseYear == 2 ? "selected" : ""}>2nd Year</option>
                <option value="3" ${courseYear == 3 ? "selected" : ""}>3rd Year</option>
                <option value="4" ${courseYear == 4 ? "selected" : ""}>4th Year</option>
                <option value="5" ${courseYear == 5 ? "selected" : ""}>5th Year</option>
                <option value="6" ${courseYear == 6 ? "selected" : ""}>Advanced</option>
            </select>
            <select name="instructor_${courseWithSection}" class="instructor-dropdown">
                <option value="">Select Instructor</option>
            </select>
            <select name="time_${courseWithSection}" class="time-dropdown" ${isServiceCourseCard ? 'required' : ''}>
                <option value="">${isServiceCourseCard ? 'Select Time (Required)' : 'Select Time (Optional)'}</option>
            </select>
            <input type="hidden" name="students_${courseWithSection}" value="25">
        `;

        // Extract course title after creating the card
        const courseName = courseCard.querySelector('label span').textContent;
        const [courseCode, courseTitle] = courseName.split(' - ');

        // Populate the instructor dropdown
        const instructorSelect = courseCard.querySelector('.instructor-dropdown');
        populateInstructorDropdown(instructorSelect);

        // Check if this is a service course
        const isServiceCourse = courseTitle.includes('(Service)');

        if (isServiceCourse) {
            const tbaOption = document.createElement('option');
            tbaOption.value = 'TBA';
            tbaOption.textContent = 'TBA (Service)';
            instructorSelect.innerHTML = '';
            instructorSelect.appendChild(tbaOption);
            instructorSelect.value = 'TBA';
            instructorSelect.disabled = true;

            const timeDropdown = courseCard.querySelector('.time-dropdown');
            timeDropdown.innerHTML = '<option value="">Select Time (Required)</option>';
            timeSlots.forEach(slot => {
                const option = document.createElement('option');
                option.value = slot;
                option.textContent = slot;
                timeDropdown.appendChild(option);
            });
        }

        // Add validation for service course time selection
        const timeDropdown = courseCard.querySelector('.time-dropdown');
        timeDropdown.addEventListener('change', () => {
            if (isServiceCourse && !timeDropdown.value) {
                timeDropdown.style.borderColor = 'red';
            } else {
                timeDropdown.style.borderColor = '';
            }
            saveCourses(true);
        });

        // Existing instructor change handler (for time slots and credit logic)
        instructorSelect.addEventListener('change', (e) => {
            const selectedInstr = e.target.value;
            const timeDropdown = courseCard.querySelector('.time-dropdown');

            // Clear time dropdown options
            timeDropdown.innerHTML = '<option value="">Select Time (Optional)</option>';

            // Handle instructor credit logic
            const courseInput = courseCard.querySelector('input[name^="courses"]');
            const courseWithSection = courseInput.value;
            const courseCode = courseWithSection.split('_')[0];
            const courseCredits = selectedCourse ? selectedCourse.credits || 0 : 0;
            const newInstr = selectedInstr;
            const oldInstr = e.target.dataset.prevInstructor || '';

            // Handle old instructor's credits
            if (oldInstr && oldInstr !== newInstr && newInstr !== 'TBA') {
                instructorCredits[oldInstr] = (instructorCredits[oldInstr] || 0) - courseCredits;
                if (instructorCredits[oldInstr] <= 0) {
                    delete instructorCredits[oldInstr];
                }
            }

            // Determine max credits based on semester
            const isSummerSemester = semester === "Summer";
            const maxCredits = isSummerSemester ? 7 : 21;

            const SchoolCode = document.querySelector('input[name="school_code"]')?.value || '';
            const TBA_instructor = 'TBA_'+ SchoolCode
            // Handle new instructor's credits (skip TBA)
            if (newInstr && newInstr !== 'TBA' && newInstr !== TBA_instructor) {
                const currentCredits = instructorCredits[newInstr] || 0;
                if (currentCredits + courseCredits > maxCredits) {
                    showCustomAlert(`Error: ${newInstr} exceeds credit limit.`);
                    e.target.value = oldInstr;
                    return;
                }
                instructorCredits[newInstr] = currentCredits + courseCredits;
            }

            // Update stored previous value
            e.target.dataset.prevInstructor = newInstr;

            // Populate time slots based on instructor availability (skip TBA)
            if (!selectedInstr || selectedInstr === 'TBA') return;
            const instructorData = instructorAvailability[selectedInstr];
            if (!instructorData || !instructorData.time_slots) return;

            // Clear and populate time slots
            timeDropdown.innerHTML = '<option value="">Select Time (Optional)</option>';
            instructorData.time_slots.forEach(slot => {
                const option = document.createElement('option');
                option.value = slot;
                option.textContent = slot;
                timeDropdown.appendChild(option);
            });

            // Save after handling instructor logic
            saveCourses(true);
        });

        // âœ… Attach save listener to all dropdowns in the course card
        courseCard.querySelectorAll('select').forEach(dropdown => {
            dropdown.addEventListener('change', () => {
                saveCourses(true);
            });
        });

        // Append the new course card to the DOM
        document.getElementById("dynamic-courses").appendChild(courseCard);
    });
</script>
    <script>
    // Form submission event listener
document.querySelector("#schedule-form").addEventListener("submit", async (e) => {
    e.preventDefault();

    // Validate instructor credits
    const isSummerSemester = semester === "Summer"; // Use the existing `semester` variable
    const maxCredits = isSummerSemester ? 7 : 21;

    const conflicts = [];
    for (const [instrId, totalCredits] of Object.entries(instructorCredits)) {
        if (totalCredits > maxCredits) {
            const instrName = instructors.find(i => i.facuser === instrId)?.facuser || 'Unknown';
            conflicts.push(`Instructor ${instrName} has ${totalCredits} credits assigned (max ${maxCredits} allowed).`);
        }
    }

    // Validate that all courses have an instructor selected
    const courseEntries = Array.from(document.querySelectorAll('.course-card'));
    courseEntries.forEach(courseCard => {
        const instructorDropdown = courseCard.querySelector('.instructor-dropdown');
        const timeDropdown = courseCard.querySelector('.time-dropdown');
        const courseName = courseCard.querySelector('label span').textContent;
        const courseTitle = courseName.split(' - ')[1] || '';
        const isServiceCourse = courseTitle.includes('(Service)');


        const SchoolCode = document.querySelector('input[name="school_code"]')?.value || '';
        const TBA_instructor = 'TBA_'+ SchoolCode

        if (instructorDropdown.value === 'TBA' || instructorDropdown.value === TBA_instructor) {
            // For service courses, validate that time is selected
            if (isServiceCourse && !timeDropdown.value) {
                conflicts.push(`Error: Time must be selected for service course ${courseName}.`);
                timeDropdown.style.borderColor = 'red';
            }
            return; // Skip other validation for TBA instructors
        }

        if (!instructorDropdown.value) {
            conflicts.push(`Error: No instructor selected for ${courseName}.`);
        }
    });

    // Display conflicts if any exist
    if (conflicts.length > 0) {
        showCustomAlert(conflicts.join("\n"));
        return;
    }

    // Check for scheduling conflicts
    courseEntries.forEach(course1 => {
        const course2Entries = courseEntries.slice(courseEntries.indexOf(course1) + 1);
        course2Entries.forEach(course2 => {
            const instr1 = course1.querySelector('.instructor-dropdown').value;
            const instr2 = course2.querySelector('.instructor-dropdown').value;
            const time1 = course1.querySelector('.time-dropdown').value;
            const time2 = course2.querySelector('.time-dropdown').value;
            const year1 = course1.querySelector('[name^="year_"]').value;
            const year2 = course2.querySelector('[name^="year_"]').value;
            const SchoolCode = document.querySelector('input[name="school_code"]')?.value || '';
            const TBA_instructor = 'TBA_'+ SchoolCode
            // Skip conflict checks if either instructor is "TBA"
            if (instr1 === 'TBA' || instr2 === 'TBA' ||  instr1 === TBA_instructor || instr2 === TBA_instructor) {
                return; // Skip this pair
            }

            if (instr1 && instr1 === instr2 && time1 && time1 === time2) {
                conflicts.push(`Conflict: ${course1.querySelector('label span').textContent} and
                                ${course2.querySelector('label span').textContent}
                                have the same instructor and time.`);
            }

            if (year1 === year2 && time1 && time1 === time2) {
                const courseCode1 = course1.querySelector('[name^="courses"]').value.split('_')[0];
                const courseCode2 = course2.querySelector('[name^="courses"]').value.split('_')[0];
                if (courseCode1 !== courseCode2) {
                    conflicts.push(`Conflict: ${course1.querySelector('label span').textContent} and
                                    ${course2.querySelector('label span').textContent}
                                    are in the same year but are different courses.`);
                }
            }
        });
    });

    if (conflicts.length > 0) {
        showCustomAlert(conflicts.join("\n"));
        return;
    }

    // Submit form data
    const formData = new FormData(e.target);
    try {
        const response = await fetch("/schedule", { method: "POST", body: formData });
        const result = await response.json();
        if (result.error) {
            showCustomAlert(`Error: ${result.error}`);
        } else {
            try{
                document.getElementById("schedule").textContent = formatSchedule(result);
            }
            catch (error){
                console.log("");
            }
        }
    } catch (error) {
        showCustomAlert(`Network Error: ${error.message}`);
    }
});
</script>
<script>
    function formatSchedule(data) {
    if (semester === "Summer") {
        return formatSummerSchedule(data);
    } else {
        return formatRegularSchedule(data);
    }
}
function formatSummerSchedule(data) {
    let text = "";
    const tableBody = document.querySelector("#editable-schedule tbody");
    tableBody.innerHTML = ""; // Clear previous rows
    const campusCode = data.campus_code || document.querySelector('input[name="campus_code"]').value || "DEFAULT_CAMPUS_CODE";

    let rowCount = 1; // Counter for row numbering

    for (const section in data) {
        if (section === "completion_time") continue;

        const [courseCode, sectionLetter] = section.split("_");
        const course = courses.find(c => c.Code === courseCode);
        const rawTime = data[section].time || 'Automatic';
        const instructor = data[section].instructor || 'TBA';
        const isServiceCourse = course && course.Title.includes('(Service)');
        const isTBAInstructor = instructor === 'TBA';

        // Parse time using the summer-specific logic
        const parsedTime = parseSummerTime(rawTime);
        const stimeTime = parsedTime.stime;
        const etimeTime = parsedTime.etime;

        // Parse days of the week
        const daysOfWeek = {
            M: 0,
            T: 0,
            W: 0,
            TH: 0,
            F: 0,
            S: 0
        };

        const days = rawTime.split(' ')[0]; // Extract days (e.g., "MWTTH")
        if (days) {
            if (days.includes('M')) daysOfWeek.M = 1;
            if (days.includes('T')) {
                daysOfWeek.T = 1; // Tuesday
                if (days.includes('TH')) daysOfWeek.TH = 1; // Thursday
            } else if (days.includes('TH')) {
                daysOfWeek.TH = 1; // Handle standalone "TH"
            }
            if (days.includes('W')) daysOfWeek.W = 1;
            if (days.includes('F')) daysOfWeek.F = 1;
            if (days.includes('S')) daysOfWeek.S = 1;
        }

        // Check if the course code contains "L" and set M and W to 0
        if (courseCode.includes("L")) {
            daysOfWeek.M = 0;
            daysOfWeek.W = 0;
        }

        // Create table row
        const row = document.createElement("tr");
        if (isServiceCourse || isTBAInstructor) {
            row.classList.add('service-course-row');
        }
        row.innerHTML = `
            <td contenteditable="true">${rowCount}</td> <!-- Row number here -->
            <td contenteditable="true">${courseCode}</td>
            <td contenteditable="true">${sectionLetter}</td>
            <td contenteditable="true">${instructor}</td>
            <td contenteditable="true">TBD</td>
            <td contenteditable="true">${stimeTime}</td>
            <td contenteditable="true">${etimeTime}</td>
            <td contenteditable="true">${daysOfWeek.M}</td>
            <td contenteditable="true">${daysOfWeek.T}</td>
            <td contenteditable="true">${daysOfWeek.W}</td>
            <td contenteditable="true">${daysOfWeek.TH}</td>
            <td contenteditable="true">${daysOfWeek.F}</td>
            <td contenteditable="true">${daysOfWeek.S}</td>
            <td contenteditable="true">${campusCode}</td>
            <td contenteditable="true">1</td>
            <td contenteditable="true" class="hidden-column">0</td>
            <td contenteditable="true" class="hidden-column">Normal</td>
            <td contenteditable="true" class="hidden-column">No</td>
            <td contenteditable="true" class="hidden-column">30</td>
        `;
        tableBody.appendChild(row);

        // Increment the row counter
        rowCount++;

        // Logging for debugging
        text += `Section ${section}:
        Time: ${stimeTime} - ${etimeTime}
        `;
    }
    return text;
}
function formatRegularSchedule(data) {
    let text = "";
    const tableBody = document.querySelector("#editable-schedule tbody");
    tableBody.innerHTML = ""; // Clear previous rows
    const campusCode = data.campus_code || document.querySelector('input[name="campus_code"]').value || "DEFAULT_CAMPUS_CODE";

    const allSectionsData = [];

    // Phase 1: Collect all section data with uppercase days for consistency
    for (const section in data) {
        if (section === "completion_time") continue;

        const [courseCode, sectionLetter] = section.split("_");
        const course = courses.find(c => c.Code === courseCode);
        const rawTime = data[section].time || 'Automatic';
        const instructor = data[section].instructor || 'TBA';
        const isServiceCourse = course && course.Title.includes('(Service)');
        const isTBAInstructor = instructor === 'TBA';

        // Parse time (same as before, unchanged)
        let stimeTime, etimeTime;
        const timePortion = rawTime.split(' ').slice(1).join(' ');
        const timeMatch = timePortion.match(/(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})\s*([AP]M)/i);
        if (timeMatch) {
            stimeTime = convertTo24Hour(`${timeMatch[1]} ${timeMatch[3]}`).trim();
            etimeTime = convertTo24Hour(`${timeMatch[2]} ${timeMatch[3]}`).trim();
        } else {
            const altMatch = timePortion.match(/(\d{1,2}:\d{2}\s*[AP]M)\s*-\s*(\d{1,2}:\d{2}\s*[AP]M)/i);
            if (altMatch) {
                stimeTime = convertTo24Hour(altMatch[1].trim());
                etimeTime = convertTo24Hour(altMatch[2].trim());
            } else {
                console.error(`[ERROR] Failed to parse time for section: ${section}, rawTime: ${rawTime}`);
                continue;
            }
        }

        // Process days to uppercase and store
        const daysStr = (rawTime.split(' ')[0] || '').toUpperCase(); // Uppercase for consistency
        const isLab = courseCode.endsWith('L');

        allSectionsData.push({
            courseCode,
            sectionLetter,
            instructor,
            rawTime,
            stimeTime,
            etimeTime,
            daysStr: daysStr,
            isLab: isLab,
            assignedDays: daysStr, // Default to original days unless changed
            isServiceCourse: isServiceCourse, // Add this flag
            isTBAInstructor: isTBAInstructor // Add this flag
        });
    }
    // Phase 2: Group and assign days for labs
    const labSections = allSectionsData.filter(sd => sd.isLab);
    const labGroups = {};

    // Group labs by time, days, and instructor (using uppercase days)
    labSections.forEach(lab => {
        const groupKey = `${lab.stimeTime}-${lab.etimeTime}-${lab.daysStr}-${lab.instructor}`;
        if (!labGroups[groupKey]) labGroups[groupKey] = [];
        labGroups[groupKey].push(lab);
    });

    // Assign individual days within each group
    Object.values(labGroups).forEach(group => {
        const daysStr = group[0].daysStr;
        const days = parseDays(daysStr); // Helper function to split days into array
        const numDays = days.length;

        group.forEach((lab, index) => {
            const dayIndex = index % numDays;
            lab.assignedDays = days[dayIndex]; // Assign a single day from the days array
        });
    });

    // Phase 3: Build table rows with corrected days
    for (const sectionData of allSectionsData) {
        const daysToShow = sectionData.isLab ? sectionData.assignedDays : sectionData.daysStr;

        // Parse days into day flags (M, T, W, TH, F, S)
        const daysOfWeek = { M: 0, T: 0, W: 0, TH: 0, F: 0, S: 0 };
        const parsedDays = parseDays(daysToShow);
        parsedDays.forEach(day => {
            switch (day) {
                case 'M': daysOfWeek.M = 1; break;
                case 'T': daysOfWeek.T = 1; break;
                case 'W': daysOfWeek.W = 1; break;
                case 'TH': daysOfWeek.TH = 1; break;
                case 'F': daysOfWeek.F = 1; break;
                case 'S': daysOfWeek.S = 1; break;
            }
        });

        // Create table row
        const row = document.createElement("tr");
        if (sectionData.isServiceCourse || sectionData.isTBAInstructor) {
            row.classList.add('service-course-row');
        }
        row.innerHTML = `
            <td>1</td>
            <td>${sectionData.courseCode}</td>
            <td>${sectionData.sectionLetter}</td>
            <td>${sectionData.instructor}</td>
            <td>TBD</td>
            <td>${sectionData.stimeTime}</td>
            <td>${sectionData.etimeTime}</td>
            <td>${daysOfWeek.M}</td>
            <td>${daysOfWeek.T}</td>
            <td>${daysOfWeek.W}</td>
            <td>${daysOfWeek.TH}</td>
            <td>${daysOfWeek.F}</td>
            <td>${daysOfWeek.S}</td>
            <td>${campusCode}</td>
            <td>1</td>
            <td class="hidden-column">0</td>
            <td class="hidden-column">Normal</td>
            <td class="hidden-column">No</td>
            <td class="hidden-column">30</td>
        `;
        tableBody.appendChild(row);

        // Logging for debugging
        text += `Section ${sectionData.courseCode}_${sectionData.sectionLetter}:
        Time: ${sectionData.stimeTime} - ${sectionData.etimeTime}
        Days: ${daysToShow}
        `;
    }
updateTableRowNumbers("editable-schedule"); // Auto-number rows

    return text;
}

// Helper function to parse days string into an array of day codes
function parseDays(daysStr) {
    const days = [];
    let i = 0;
    while (i < daysStr.length) {
        if (i + 1 < daysStr.length && daysStr[i] === 'T' && daysStr[i + 1] === 'H') {
            days.push('TH');
            i += 2;
        } else {
            days.push(daysStr[i]);
            i += 1;
        }
    }
    return days;
}
function convertTo24Hour(timeStr) {
    console.log("[DEBUG] Converting time to 24-hour format. Input:", timeStr);

    // Handle summer format (no AM/PM)
    if (!timeStr.includes('AM') && !timeStr.includes('PM')) {
        const [hourStr, minute] = timeStr.split(':');
        let hourInt = parseInt(hourStr, 10);

        // Assume times with single-digit hours (less than 8) are PM
        if (hourInt < 8) {
            hourInt += 12; // Convert to PM by adding 12 hours
        }

        // Format the hour with leading zeros
        const hour24 = String(hourInt).padStart(2, '0');
        return `${hour24}:${minute}`;
    }

    // Handle regular semester format (with AM/PM)
    const parts = timeStr.trim().split(/\s+/);
    if (parts.length < 2) {
        console.error("Invalid time format:", timeStr);
        return '';
    }

    const timePart = parts[0];
    const period = parts[1].toUpperCase();
    const [hourStr, minute] = timePart.split(':');
    let hourInt = parseInt(hourStr, 10);

    // Adjust hour based on AM/PM
    if (period === "PM" && hourInt !== 12) {
        hourInt += 12;
    } else if (period === "AM" && hourInt === 12) {
        hourInt = 0;
    }

    // Format the hour with leading zeros
    const hour24 = String(hourInt).padStart(2, '0');
    return `${hour24}:${minute}`;
}
function parseSummerTime(rawTime) {
    console.log("[DEBUG] Parsing summer time. Input:", rawTime);

    // Extract the time portion (everything after the days)
    const timePortion = rawTime.split(' ').slice(1).join(' ');

    // Split the time range into start and end times
    const [startTime, endTime] = timePortion.split('-').map(t => t.trim());

    // Helper function to convert a single time to 24-hour format
    const convertTo24Hour = (time) => {
        const [hourStr, minute] = time.split(':');
        let hourInt = parseInt(hourStr, 10);

        // Assume times with single-digit hours (less than 8) are PM
        if (hourInt < 8) {
            hourInt += 12; // Convert to PM by adding 12 hours
        }

        // Format the hour with leading zeros
        const hour24 = String(hourInt).padStart(2, '0');
        return `${hour24}:${minute}`;
    };

    // Parse start and end times
    const stime = convertTo24Hour(startTime);
    const etime = convertTo24Hour(endTime);

    // Return parsed times
    return {
        stime,
        etime
    };
}
    function showCustomAlert(message, duration = 5000) {
    const alertBox = document.getElementById('custom-alert');
    const messageElement = alertBox.querySelector('.message');
    const progressBarInner = alertBox.querySelector('.progress-bar-inner');

    // Clean up the message content
    message = message.trim().replace(/\n+/g, '\n'); // Remove extra line breaks

    // Reset the progress bar animation
    progressBarInner.style.animation = 'none';
    void progressBarInner.offsetWidth; // Trigger reflow to restart animation
    progressBarInner.style.animation = `shrink-progress-bar ${duration}ms linear forwards`;

    // Update the message content
    messageElement.textContent = message;

    // Show the alert box
    alertBox.style.display = 'block';
    alertBox.style.opacity = 1;

    // Force the browser to recalculate the height
    alertBox.style.height = 'auto'; // Reset height to auto
    alertBox.scrollTop = 0; // Scroll to the top (useful for long messages)

    // Hide the alert box after the specified duration
    setTimeout(() => {
        alertBox.style.opacity = 0;
        setTimeout(() => {
            alertBox.style.display = 'none';
        }, 500); // Match this duration with the CSS transition duration
    }, duration);
}
</script>
<script>
function removeCourse(courseWithSection) {
    // Remove the course from the `addedCourses` set
    addedCourses.delete(courseWithSection);

    // Split the course code and section letter
    const [courseCode, sectionLetter] = courseWithSection.split('_');

    // Find the course details to get its credits
    const selectedCourse = courses.find(c => c.Code === courseCode);
    const courseCredits = selectedCourse ? selectedCourse.credits || 0 : 0; // Default to 0 if course is not found

    // Remove the section from the `courseSections` object
    if (courseSections[courseCode]) {
        const index = courseSections[courseCode].indexOf(sectionLetter);
        if (index > -1) {
            courseSections[courseCode].splice(index, 1); // Remove the section letter
            if (courseSections[courseCode].length === 0) {
                delete courseSections[courseCode]; // Delete the course code if no sections remain
            }
        }
    }

    // Find the instructor assigned to this course
    const courseCard = document.querySelector(`[value="${courseWithSection}"]`).closest(".course-card");
    const instructorDropdown = courseCard.querySelector('.instructor-dropdown');
    const selectedInstr = instructorDropdown.value;

    // Update the instructor's total credits
    if (selectedInstr) {
        instructorCredits[selectedInstr] = (instructorCredits[selectedInstr] || 0) - courseCredits;
        // If the instructor has no credits left, reset their entry in the object
        if (instructorCredits[selectedInstr] <= 0) {
            delete instructorCredits[selectedInstr];
        }
    }

    // Remove the course card from the DOM
    courseCard.remove();
    saveCourses(silent=true);
}
</script>
<script>
    function updateTableRowNumbers(tableId) {
    const table = document.getElementById(tableId);
    if (!table) return;

    const tbody = table.querySelector("tbody");
    const rows = tbody.querySelectorAll("tr");

    rows.forEach((row, index) => {
        const numberCell = row.querySelector("td:first-child");
        if (numberCell) {
            numberCell.textContent = index + 1;
        }
    });
}
</script>
</body>
<style>
  /* Custom Alert Styling */
        #custom-alert {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 25px 40px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: none;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            line-height: 1.5;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
            width: 350px;
        }

        /* Progress Bar for Timer */
        #custom-alert .progress-bar {
            margin-top: 15px;
            height: 8px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        #custom-alert .progress-bar-inner {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00bfff, #0074b2);
            animation: shrink-progress-bar 5s linear forwards;
        }

        @keyframes shrink-progress-bar {
            from { width: 100% }
            to { width: 0% }
        }

</style>
<script>
document.getElementById("export-excel-btn").addEventListener("click", () => {
    const table = document.getElementById("editable-schedule");
    const rows = table.querySelectorAll("tr");

    // Check if the table has data rows
    if (rows.length <= 1) {
        alert("The table is empty. Please add data before exporting.");
        return;
    }

    // Extract headers
    const headers = Array.from(rows[0].querySelectorAll("th"))
        .map(th => th.textContent.trim());

    // Find the index of the 'FACUSER' column
    const facuserColIndex = headers.indexOf("FACUSER");
    if (facuserColIndex === -1) {
        alert("FACUSER column not found!");
        return;
    }

    // Extract and filter data rows (skip rows where FACUSER is 'TBA')
    const data = [];
    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].querySelectorAll("td");
        const rowData = Array.from(cells).map(cell => cell.textContent.trim());
        if (rowData[facuserColIndex] === "TBA") continue;
        data.push(rowData);
    }

    if (data.length === 0) {
        alert("No valid data to export. All instructors are marked as TBA.");
        return;
    }

    // Get metadata from hidden form fields
    const schoolCode = document.querySelector('input[name="school_code"]').value;
    const campusCode = document.querySelector('input[name="campus_code"]').value;
    const academicYear = document.querySelector('input[name="academic_year"]').value;
    const semester = document.querySelector('input[name="semester"]').value;

    // âœ… Send data to server to save to database
    fetch('/save_schedule', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            headers,
            scheduleData: data,
            schoolCode,
            campusCode,
            academicYear,
            semester
        }),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Server responded with an error.');
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            alert('Schedule saved to database successfully!');
        } else {
            alert('Failed to save schedule to database.');
        }
    })
    .catch(error => {
        console.error('Error saving schedule:', error);
        alert('An error occurred while saving the schedule to the database.');
    });

    // Create a worksheet
    const worksheet = XLSX.utils.json_to_sheet([headers, ...data], { skipHeader: true });

    // Define styles
    const headerStyle = {
        fill: { fgColor: { rgb: "D3D3D3" } }, // Grey background
        font: { bold: true },
        alignment: { horizontal: "center" },
        border: {
            top: { style: "thin", color: { rgb: "000000" } },
            bottom: { style: "thin", color: { rgb: "000000" } },
            left: { style: "thin", color: { rgb: "000000" } },
            right: { style: "thin", color: { rgb: "000000" } }
        }
    };

    const cellStyle = {
        border: {
            top: { style: "thin", color: { rgb: "000000" } },
            bottom: { style: "thin", color: { rgb: "000000" } },
            left: { style: "thin", color: { rgb: "000000" } },
            right: { style: "thin", color: { rgb: "000000" } }
        }
    };

    // Apply styles to the header row
    for (let colIndex = 0; colIndex < headers.length; colIndex++) {
        const cellAddress = XLSX.utils.encode_cell({ r: 0, c: colIndex });
        if (!worksheet[cellAddress]) continue;
        worksheet[cellAddress].s = headerStyle;
    }

    // Apply styles to data cells
    for (let rowIndex = 1; rowIndex <= data.length; rowIndex++) {
        for (let colIndex = 0; colIndex < headers.length; colIndex++) {
            const cellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: colIndex });
            if (!worksheet[cellAddress]) continue;
            worksheet[cellAddress].s = cellStyle;
        }
    }

    // Auto-fit column widths
    const columnWidths = headers.map((header, index) => {
        const maxLength = Math.max(
            header.length,
            ...data.map(row => row[index]?.length || 0)
        );
        return { wch: maxLength + 2 };
    });

    worksheet["!cols"] = columnWidths;

    // Create and save workbook
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Schedule");
    XLSX.writeFile(workbook, "schedule.xlsx");
});
</script>
</html>